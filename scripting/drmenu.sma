/* Plugin generated by AMXX-Studio */

/*================================================================================
	Seccion personalizable
=================================================================================*/

new const PREFIX[] = "[DR Peru]";	//Prefijo

new const ANIMALES[][] =		//Animales para la suerte. Si agregas mas, sera mas dificil acertar.
{
	"Alpaca",
	"Guanaco",
	"Pony",
	"Cabrito",
	"Chivo",
	"Tarantula",
	"Mosquito"
};

new const SONIDOS[][] =		//Sonidos para reproducir. El archivo debe tener el nombre exacto
{				//Asi como estar en formato .wav y estar en la carpeta sound/Deathrun_Sounds
	"Imbecil",
	"Yahoo",
	"Whooaaa",
	"Aaaaaarg",
	"TouchThis",
	"MenInBlack",
	"BeHappy"
};

new const TRAIL_COLORES[31][] = 	//Puedes editar los nombres pero NO agregar nuevos colores ni cambiar el orden.
{
	"Aleatorio"
	,"Azul"
	,"Rojo"
	,"Verde"
	,"Amarillo"
	,"Blanco"
	,"Morado"
	,"Rosado"
	,"Chocolate"
	,"Dorado"
	,"Plateado"
	,"Agua"
	,"Agua marina"
	,"Beige"
	,"Violeta"
	,"Marron"
	,"Cian"
	,"Fucsia"
	,"Gris"
	,"Hielo"
	,"Lima limon"
	,"Magenta"
	,"Azul nocturno"
	,"Azul naval"
	,"Oliva"
	,"Naranja"
	,"Azul real"
	,"Celeste"
	,"Nieve"
	,"Azul metalico"
	,"Violeta"
};

new const TRAIL_TIPOS[12][] =	//Lo mismo que los colores...
{
	"Linear",
	"Puntos",
	"Salchichas",
	"Estrellas",
	"Burbujas",
	"Tiza",
	"Humo",
	"Cordon",
	"Rayo",
	"Manchas",
	"Haz luminoso",
	"Rastro fugaz"
};

/*================================================================================
	Aqui termina la seccion personalizable del plugin.
	Proceder no esta soportado, hagalo bajo su propio riesgo...
=================================================================================*/

#pragma semicolon 1

#include <amxmodx>
#include <fakemeta>
#include <engine>
#include <hamsandwich>
#include <cstrike>
#include <fun>

#define PLUGIN "Deathrun Menu"
#define VERSION "1.2"

#define MENUPROP_CANCEL		menu_setprop(menu, MPROP_EXITNAME, "\yCancelar^n");
#define MENUPROP_BACK		menu_setprop(menu, MPROP_BACKNAME, "Anterior");
#define MENUPROP_NEXT		menu_setprop(menu, MPROP_NEXTNAME, "Siguiente^n");
#define MENUPROP_RED		menu_setprop(menu, MPROP_NUMBER_COLOR, "\r");

#define is_player_connected(%0) (g_Connected & (1 << %0-1))

//Variables globales
new bool:g_bTyped[33], bool:g_HasLuck[33], bool:g_HasVotedRR[33], g_TrailColor[33], g_VotesNeeded, g_VotesForRR,
g_Points[33], g_MenuPlayers[33], bool:g_Mute[33][33], bool:g_Camera[33], g_Connected,
bool:g_HasSpeed[33], g_Confirmation[33], g_PlayerName[33][33], g_Terrorist, g_FreeRoundCounter;

//Natives
native trailcmd(index, thetypenum, thecolornum);
native parachutecmd(index);
native bunnycmd(index);

native maricacmd(index);
native chatcmd(index);
native checkmarica(index);
native checkchat(index);

native speedometercmd(index);
native checkspeed(index);

native slowdowncmd(index);
native checkslowdown(index);

native freeroundcmd(index);
native checkfreeround();

native unstuckcmd(index);

public plugin_precache()
{
	new buffer[31];
	for(new i = 0; i < sizeof(SONIDOS); i++)
	{
		buffer[0] = '^0';
		formatex(buffer, 30, "Deathrun_Sounds/%s.wav", SONIDOS[i]);
		precache_sound(buffer);
	}
	
	precache_model("models/rpgrocket.mdl");
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, "Mia2904");
	
	register_event("DeathMsg", "event_DeathMsg", "a");
	register_event("HLTV", "event_HLTV", "a", "1=0", "2=0");
	register_event("CurWeapon","event_CurWeapon","b");
	
	register_forward(FM_Voice_SetClientListening, "fw_Voice");
	register_forward(FM_Touch, "fw_Touch");
	
	register_clcmd("chooseteam", "clcmd_ChooseTeam", -1);
	register_clcmd("jointeam", "clcmd_JoinTeam");
	
	register_clcmd("say /speed", "clcmd_SaySpeed");
	register_clcmd("say /cam", "clcmd_SayCam");
	
	register_clcmd("say /v", "clcmd_menu");
	register_clcmd("say /menu", "clcmd_menu");
	register_clcmd("say_team /v", "clcmd_menu");
	register_clcmd("say_team /menu", "clcmd_menu");
	
	register_clcmd("say rr", "clcmd_voterr");
	register_clcmd("say /rr", "clcmd_voterr");
	register_clcmd("say_team rr", "clcmd_voterr");
	register_clcmd("say_team /rr", "clcmd_voterr");
	
	register_concmd("darpuntos", "concmd_DarPuntos", ADMIN_RCON);
	
	register_menucmd(register_menuid("FreeRoundMenu"), (1<<0)|(1<<1), "menu_freeround");
	register_menucmd(register_menuid("ConfirmationMenu"), (1<<0)|(1<<1), "menu_confirmation");
}

public plugin_cfg()
{
	set_cvar_num("sv_maxspeed", 600);
	set_cvar_num("sv_airaccelerate", 100);
}

public show_menu_freeround(id)
{
	id -= 531;
	
	if(!g_FreeRoundCounter)
	{
		menu_freeround(id, -1);
		print_color(0, "^x03%s^x01 El terrorista no ha decidido. Se continua con una^x04 Ronda sin trampas.", PREFIX);
		return PLUGIN_HANDLED;
	}
	
	static freeroundmenu[100]; 
	new len;
	
	g_FreeRoundCounter--;
	
	len += formatex(freeroundmenu[len], 99 - len, "\r%s\y Ronda sin trampas?^n^n", PREFIX);
	len += formatex(freeroundmenu[len], 99 - len, "\r1.\w Si^n\r2.\w No^n^n^n\ySegundos restantes:\r %d", g_FreeRoundCounter);
	
	if(g_FreeRoundCounter) show_menu(id, (1<<0)|(1<<1), freeroundmenu, -1, "FreeRoundMenu");
	else show_menu(id, (1<<0)|(1<<1), freeroundmenu, 1, "FreeRoundMenu");

	set_task(1.0, "show_menu_freeround", id + 531);
	
	return PLUGIN_HANDLED;
}

public menu_freeround(id, key)
{
	if(task_exists(id + 531)) remove_task(id + 531);
	
	show_menu(id, 0, "", 1);
	
	if(get_pdata_int(id, 114, 5) != 1) return PLUGIN_HANDLED;
	
	if(key < 1)
	{
		freeroundcmd(id);
		for(new i = 1; i < 33; i++) PlayerRespawn(i);
	}
	
	if(!key) print_color(0, "^x03%s^x01 El terrorista ha elegido una^x04 Ronda sin trampas.", PREFIX);
	
	return PLUGIN_HANDLED;
}

show_menu_deathrun(id)
{
	static dr_menu_name[30 + sizeof(PREFIX)], items[40];
	formatex(dr_menu_name, charsmax(dr_menu_name), "\r%s\y Menu Principal", PREFIX);
	
	new menu = menu_create(dr_menu_name, "menu_deathrun");
	
	menu_additem(menu, "Tienda de Extra Items", "", 0);
	
	if(!g_HasLuck[id]) menu_additem(menu, "Prueba tu Suerte^n", "", 0);
	else menu_additem(menu, "\dPrueba tu Suerte^n", "", 0);
	
	menu_additem(menu, "Elegir un Trail", "", 0);
	
	if(g_Terrorist == id) menu_additem(menu, "Reproducir un sonido", "", 0);
	else menu_additem(menu, "Destrabar (Unstuck)", "", 0);
	
	menu_additem(menu, "Silenciar a un jugador^n", "", 0);
	
	formatex(items, 39, "Medidor de velocidad\y [%sctivado]", checkspeed(id) ? "A" : "Desa");
	menu_additem(menu, items, "", 0);
	
	formatex(items, 39, "Posicion de la camara\y [%s]", g_Camera[id] ? "3ra persona" : "Normal");
	menu_additem(menu, items, "", 0);
	
	formatex(items, 39, "Ayuda para Bunny Hop\y [%sctivado]^n", checkslowdown(id) ? "A" : "Desa");
	menu_additem(menu, items, "", 0);
	
	if(get_user_flags(id) & ADMIN_KICK) menu_additem(menu, "Menu de Admin^n", "", 0);
	else menu_additem(menu, "\dMenu de Admin^n", "", 0);
	
	menu_additem(menu, "\ySalir^n", "0", 0); /*^n^n^n^n^n", "0");*/
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_ALL);
	menu_setprop(menu, MPROP_PERPAGE, 0);
	MENUPROP_RED

	menu_display(id, menu, 0);

	return PLUGIN_HANDLED;
}

public menu_deathrun(id, menu, key)
{
	switch(key)
	{
		case 0: show_menu_extras(id);
		case 1:
		{
			if(!g_HasLuck[id]) show_menu_luck(id);
			else
			{
				print_color(id, "^x03%s^x01 Solo puedes probar tu suerte una vez por ronda.", PREFIX);
				show_menu_deathrun(id);
			}
		}
		case 2: show_menu_trail_color(id);
		case 3:
		{
			if(g_Terrorist == id) show_menu_sounds(id);
			else if(unstuckcmd(id)) print_color(id, "^x03%s^x01 Has sido destrabado.", PREFIX);
			else print_color(id, "^x03%s^x01 No estas trabado.", PREFIX);
		}
		case 4: show_menu_players(id, 1);
		case 5:
		{
			speedometercmd(id);
			show_menu_deathrun(id);
		}
		case 6:
		{
			if(is_user_alive(id))
			{
				if(g_Camera[id])
				{
					set_view(id, CAMERA_NONE);
					g_Camera[id] = false;
				}
				else
				{
					set_view(id, CAMERA_3RDPERSON);
					g_Camera[id] = true;
				}
			}
			
			show_menu_deathrun(id);
		}
		case 7:
		{
			slowdowncmd(id);
			show_menu_deathrun(id);
		}
		case 8:
		{
			if(get_user_flags(id) & ADMIN_KICK) show_menu_admin(id);
			else show_menu_deathrun(id);
		}
	}
	
	if(menu) menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_extras(id)
{
	static menutitle[51];
	formatex(menutitle, 50, "\r[Tienda]\y Elige un extra!^nTienes\r %d\y punt%s.", g_Points[id], g_Points[id] == 1 ? "o" : "os");
	new menu = menu_create(menutitle, "menu_extras");
	
	if(g_Points[id] > 0) menu_additem(menu, "[1] 255 de HP", "", 0);
	else menu_additem(menu, "\d[1] 255 de HP", "", 0);
	
	if(g_Points[id] > 1)
	{
		menu_additem(menu, "[2] Bunny Hop (1 ronda)", "", 0);
		menu_additem(menu, "[2] Paracaidas (1 ronda)", "", 0);
		menu_additem(menu, "[2] Mas velocidad (1 ronda)", "", 0);
	}
	else
	{
		menu_additem(menu, "\d[2] Bunny Hop (1 ronda)", "", 0);
		menu_additem(menu, "\d[2] Paracaidas (1 ronda)", "", 0);
		menu_additem(menu, "\d[2] Mas velocidad (1 ronda)", "", 0);
	}
	
	if(g_Points[id] > 2) menu_additem(menu, "[3] Volver marica a un jugador (1 ronda)", "", 0);
	else menu_additem(menu, "\d[3] Volver marica a un jugador (1 ronda)", "", 0);
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_NORMAL);
	MENUPROP_CANCEL
	MENUPROP_BACK
	MENUPROP_NEXT
	MENUPROP_RED
	
	menu_display(id, menu, 0);
}

public menu_extras(id, menu, key)
{
	if(key == MENU_EXIT)
	{
		show_menu_deathrun(id);
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	if(!is_user_alive(id) && key != 4)
	{
		print_color(id, "^x03%s^x01 Tienes que estar vivo para comprar un extra.", PREFIX);
		show_menu_deathrun(id);
		key = -1;
	}
	
	switch(key)
	{
		case 0:
		{
			if(g_Points[id] > 0)
			{
				g_Points[id]--;
				print_color(id, "^x03%s^x01 Has comprado 255 de HP.", PREFIX);
				set_user_health(id, 255);
			}
			else
			{
				print_color(id, "^x03%s^x01 Necesitas mas puntos para comprar esto.", PREFIX);
				show_menu_deathrun(id);
			}
		}
		case 1:
		{
			if(g_Points[id] > 1)
			{
				g_Points[id] -= 2;
				print_color(id, "^x03%s^x01 Has comprado Bunny Hop.", PREFIX);
				bunnycmd(id);
			}
			else
			{
				print_color(id, "^x03%s^x01 Necesitas mas puntos para comprar esto.", PREFIX);
				show_menu_deathrun(id);
			}
		}
		case 2:
		{
			if(g_Points[id] > 1)
			{
				g_Points[id] -= 2;
				print_color(id, "^x03%s^x01 Has comprado un Paracaidas.", PREFIX);
				parachutecmd(id);
			}
			else
			{
				print_color(id, "^x03%s^x01 Necesitas mas puntos para comprar esto.", PREFIX);
				show_menu_deathrun(id);
			}
		}
		case 3:
		{
			if(g_Points[id] > 1)
			{
				g_Points[id] -= 2;
				print_color(id, "^x03%s^x01 Has comprado Mas Velocidad.", PREFIX);
				g_HasSpeed[id] = true;
				event_CurWeapon(id);
			}
			else
			{
				print_color(id, "^x03%s^x01 Necesitas mas puntos para comprar esto.", PREFIX);
				show_menu_deathrun(id);
			}
		}
		case 4:
		{
			if(g_Points[id] > 2) show_menu_players(id, 0);
			else
			{
				print_color(id, "^x03%s^x01 Necesitas mas puntos para comprar esto.", PREFIX);
				show_menu_deathrun(id);
			}
		}
	}
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_players(id, from, page = 0)
{
	g_MenuPlayers[id] = from;
	
	static menutitle[42], menushow[50], userid[8];
	
	switch(from)
	{
		case 0: formatex(menutitle, 41, "\r[Marica]\y Elige un jugador%s", get_playersnum() > 8 ? "^nPagina:\r" : "" );
		case 1: formatex(menutitle, 41, "\r[Silenciar]\y Elige un jugador%s", get_playersnum() > 8 ? "^nPagina:\r" : "" );
		case 2: formatex(menutitle, 41, "\r[Callar]\y Elige un jugador%s", get_playersnum() > 8 ? "^nPagina:\r" : "" );
		case 3: formatex(menutitle, 41, "\r[Revivir]\y Elige un jugador%s", get_playersnum() > 8 ? "^nPagina:\r" : "" );
	}
	
	new menu = menu_create(menutitle, "menu_players");
	
	for(new i = 1; i < 33; i++)
	{
		if(!is_player_connected(i)) continue;
		
		switch(from)
		{
			case 0: formatex(menushow, 39, "%s %s", g_PlayerName[i], checkmarica(i) ? "\y(Ya es marica)" : "");
			case 1: formatex(menushow, 39, "%s %s", g_PlayerName[i], g_Mute[id][i] ? "\y(Silenciado)" : "");
			case 2: formatex(menushow, 39, "%s %s", g_PlayerName[i], checkchat(i) ? "\y(Callado)" : "");
			case 3: formatex(menushow, 39, "%s%s", is_user_alive(i) ? "\d" : "", g_PlayerName[i]);
		}
		
		num_to_str(get_user_userid(i), userid, charsmax(userid));
		
		menu_additem(menu, menushow, userid, 0);
	}
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_NORMAL);
	menu_setprop(menu, MPROP_EXITNAME, "\ySalir");
	MENUPROP_BACK
	MENUPROP_NEXT
	MENUPROP_RED
	
	menu_display(id, menu, page);
	
	return PLUGIN_HANDLED;
}

public menu_players(id, menu, key)
{
	if(key == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new player, userid[8];
	menu_item_getinfo(menu, key, player, userid, charsmax(userid), _, _, player);
	
	player = find_player("k", str_to_num(userid));
	
	if(player) switch(g_MenuPlayers[id])
	{
		case 0:
		{
			g_Points[id] -= 3;
			maricacmd(player);
			print_color(id, "^x03%s^x01 Has vuelto marica a^x04 %s", PREFIX, g_PlayerName[player]);
		}
		case 1:
		{
			g_Mute[id][player] = !(g_Mute[id][player]);
			print_color(id, "^x03%s^x01 Has %silenciado a^x04 %s", PREFIX, g_Mute[id][player] ? "s" : "des", g_PlayerName[player]);
		}
		case 2:
		{
			chatcmd(player);
			print_color(id, "^x03%s^x01 Has %sctivado el chat a^x04 %s", PREFIX, checkchat(player) ? "des" : "rea" , g_PlayerName[player]);
		}
		case 3:
		{
			if(!is_user_alive(player))
			{
				PlayerRespawn(player);
				print_color(id, "^x03%s^x01 ADMIN^x04 %s^x01 - Ha revivido a %s", PREFIX, g_PlayerName[id], g_PlayerName[player]);
			}
		}
	}
	
	if(g_MenuPlayers[id] > 0)
	{
		new page;
		while (key > 6)
		{
			key -= 7;
			page++;
		}
		
		show_menu_players(id, g_MenuPlayers[id], page);
	}
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_luck(id)
{
	new menu = menu_create("\r[Suerte]\y Elige un Animal!", "menu_luck");
	
	for(new i = 0; i < sizeof(ANIMALES); i++)
	{
		menu_additem(menu, ANIMALES[i], "", 0);
	}
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_NORMAL);
	MENUPROP_CANCEL
	MENUPROP_BACK
	MENUPROP_NEXT
	MENUPROP_RED
	
	menu_display(id, menu, 0);
}

public menu_luck(id, menu, key)
{
	if(key == MENU_EXIT)
	{
		show_menu_deathrun(id);
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	g_HasLuck[id] = true;
	new therandom = random_num(0, charsmax(ANIMALES));
	if(key == therandom)
	{
		print_color(id, "^x03%s^x01 Felicidades, has acertado. Recompensa:^x04 1^x01 punto.", PREFIX);
		g_Points[id]++;
	}
	else print_color(id, "^x03%s^x01 Mala suerte! El animal que salio fue^x04 %s.", PREFIX, ANIMALES[therandom]);
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_sounds(id)
{
	new menu = menu_create("\r[Sonidos]\y Elige un Sonido!", "menu_sounds");
	
	for(new i = 0; i < sizeof(SONIDOS); i++)
	{
		menu_additem(menu, SONIDOS[i], "", 0);
	}
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_NORMAL);
	MENUPROP_CANCEL
	MENUPROP_BACK
	MENUPROP_NEXT
	MENUPROP_RED
	
	menu_display(id, menu, 0);
}

public menu_sounds(id, menu, key)
{
	if(key == MENU_EXIT)
	{
		show_menu_deathrun(id);
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	static buffer[35];
	formatex(buffer, 34, "spk Deathrun_Sounds/%s.wav", SONIDOS[key]);
	
	for(new i = 1; i < 33; i++)
	{
		if(!is_user_connected(i)) continue;
		
		if(g_Mute[i][id]) continue;
		
		client_cmd(i, "stopsound");
		client_cmd(i, buffer);
	}
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_admin(id)
{
	static admin_menu_name[30 + sizeof(PREFIX)];
	formatex(admin_menu_name, charsmax(admin_menu_name), "\r%s\y Menu de Admin", PREFIX);
	
	new menu = menu_create(admin_menu_name, "menu_admin");
	
	menu_additem(menu, "Menu de Chat Mute", "", 0);
	menu_additem(menu, "Menu de Slap/Slay", "", 0);
	menu_additem(menu, "Menu de Revivir", "", 0);
	menu_additem(menu, "Menu de Kick", "", 0);
	menu_additem(menu, "Menu de Ban^n", "", 0);
	menu_additem(menu, "Cambiar el mapa", "", 0);
	menu_additem(menu, "Reiniciar la ronda^n", "", 0);
	menu_additem(menu, "Chat de Admins", "", 0);
	menu_additem(menu, "Calculadora^n", "", 0);
	
	menu_additem(menu, "\ySalir", "0");
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_ALL);
	menu_setprop(menu, MPROP_PERPAGE, 0);
	MENUPROP_RED

	menu_display(id, menu, 0);

	return PLUGIN_HANDLED;
}

public menu_admin(id, menu, key)
{
	switch(key)
	{
		case 0: show_menu_players(id, 2);
		case 1: client_cmd(id, "amx_slapmenu");
		case 2: show_menu_players(id, 3);
		case 3: client_cmd(id, "amx_kickmenu");
		case 4: client_cmd(id, "amx_banmenu");
		case 5 .. 6:
		{
			g_Confirmation[id] = key - 5;
			show_menu_confirmation(id);
		}
		case 7: client_cmd(id, "messagemode amx_chat");
		case 8: client_cmd(id, "calculator");
	}
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_trail_color(id)
{
	new menu = menu_create("\r[Trail]\y Elegir el Color^nPagina:\r", "menu_trail_color");
	
	for(new i = 0; i < sizeof(TRAIL_COLORES); i++)
	{
		menu_additem(menu, TRAIL_COLORES[i], "", 0);
	}
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_ALL);
	MENUPROP_CANCEL
	MENUPROP_BACK
	MENUPROP_NEXT
	MENUPROP_RED

	menu_display(id, menu, 0);

	return PLUGIN_HANDLED;
}

public menu_trail_color(id, menu, key)
{
	if(key == MENU_EXIT)
	{
		show_menu_deathrun(id);
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	if(!key) key = random_num(1, 30);
	
	g_TrailColor[id] = key;
	show_menu_trail_type(id);
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}
	
show_menu_trail_type(id)
{
	new menu = menu_create("\r[Trail]\y Elegir la Forma^nPagina:\r", "menu_trail_type");
	
	for(new i = 0; i < sizeof(TRAIL_TIPOS); i++)
	{
		menu_additem(menu, TRAIL_TIPOS[i], "", 0);
	}
	
	menu_setprop(menu, MPROP_EXIT, MEXIT_ALL);
	menu_setprop(menu, MPROP_EXITNAME, "\yCancelar\r (Quitar Trail)^n");
	MENUPROP_BACK
	MENUPROP_NEXT
	MENUPROP_RED

	menu_display(id, menu, 0);

	return PLUGIN_HANDLED;
}

public menu_trail_type(id, menu, key)
{
	if(key == MENU_EXIT)
	{
		trailcmd(id, 0, 0);
		print_color(id, "^x03%s^x01 Ahora no llevas un trail.", PREFIX);
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	trailcmd(id, key + 1, g_TrailColor[id]);
	print_color(id, "^x03%s^x01 Ahora llevas un trail de color^x04 %s.", PREFIX, TRAIL_COLORES[g_TrailColor[id]]);
	
	menu_destroy(menu);
	return PLUGIN_HANDLED;
}

show_menu_confirmation(id)
{
	static confirmationmenu[100];
	
	formatex(confirmationmenu, 99, "\r[Confirmar]\y %s?^n^n\r1.\w Si^n\r2.\w No", !g_Confirmation[id] ? "Cambiar el mapa" : "Reiniciar la ronda");
	
	show_menu(id, (1<<0)|(1<<1), confirmationmenu, -1, "ConfirmationMenu");
	
	return PLUGIN_HANDLED;
}

public menu_confirmation(id, key)
{
	if(key == 1) return PLUGIN_HANDLED;
	
	switch(g_Confirmation[id])
	{
		case 0:
		{
			server_cmd("gal_startvote");
			print_color(0, "^x03%s^x01 Admin^x04 %s^x01 - Votacion de mapas", PREFIX, g_PlayerName[id]);
		}
		case 1:
		{
			set_cvar_float("sv_restartround", 1.0);
			print_color(0, "^x03%s^x01 Admin^x04 %s^x01 - Reiniciar el mapa", PREFIX, g_PlayerName[id]);
		}
	}
	
	return PLUGIN_HANDLED;
}

public client_putinserver(id)
{
	if(get_user_flags(id) & ADMIN_IMMUNITY) g_Points[id] = 100;
	else g_Points[id] = 0;
	
	g_Connected |= (1 << id-1);
	
	g_HasLuck[id] = false;
	g_HasVotedRR[id] = false;
	
	get_user_name(id, g_PlayerName[id], 32);
	
	set_task(10.0, "task_showmessage", id + 632);
	
	for(new i = 1; i < 33; i++) g_Mute[id][i] = false;
}

public client_disconnect(id)
{
	if(task_exists(id + 632)) remove_task(id + 632);
	if(task_exists(id + 531)) remove_task(id + 531);
	
	g_Connected &= ~(1 << id-1);
}

public client_infochanged(id)
{
	get_user_info(id, "name", g_PlayerName[id], 32);
	
	return PLUGIN_HANDLED;
}

public task_showmessage(id) print_color(id - 632, "^x03%s^x01 Presiona^x04 M^x01 para mostrar el menu.", PREFIX);

public clcmd_ChooseTeam(id)
{
	if(0 < get_pdata_int(id, 114, 5) < 3)
	{
		g_bTyped[id] = true;
		show_menu_deathrun(id);

		return PLUGIN_HANDLED;
	}

	return PLUGIN_CONTINUE;
}

public message_VGUIMenu(iMsgid, iDest, id)
{
	if(!g_bTyped[id])
	{
		return PLUGIN_CONTINUE;
	}
	if(get_msg_arg_int(1) != 2)
	{
		return PLUGIN_CONTINUE;
	}

	g_bTyped[id] = false;
	set_msg_block(iMsgid, BLOCK_ONCE);
	set_msg_block(iMsgid, BLOCK_NOT);
	return PLUGIN_HANDLED;
}

public clcmd_menu(id)
{
	if(0 < get_pdata_int(id, 114, 5) < 3) show_menu_deathrun(id);
	
	return PLUGIN_HANDLED;
}

public fw_Touch(ent, toucher)
{
	static classname[15];
	
	if (g_Terrorist != toucher || !is_user_alive(toucher)) return FMRES_IGNORED;
	
	if (pev_valid(ent) != 2) return FMRES_IGNORED;
	
	pev(ent, pev_classname, classname, 14);
	
	if (equal(classname, "weaponbox")) return FMRES_SUPERCEDE;
	
	return FMRES_IGNORED;
}

public fw_Voice(receiver, sender, listen) 
{
	if(receiver == sender)
		return FMRES_IGNORED;
		
	if(g_Mute[receiver][sender])
	{
		engfunc(EngFunc_SetClientListening, receiver, sender, 0);
		return FMRES_SUPERCEDE;
	}
	
	return FMRES_IGNORED;
}

public Event_TeamInfo()
{
	static id, selectedteam[2];
	
	if(!checkfreeround()) return;
	
	id = read_data(1); 
	read_data(2, selectedteam, 1);
	if(selectedteam[0] == 'C') PlayerRespawn(id);
}

public event_CurWeapon(id)
{
	if(!is_user_connected(id) || !g_HasSpeed[id]) return;
	
	set_user_maxspeed(id, 340.0);
}

public event_HLTV()
{
	g_Terrorist = -1;
	g_FreeRoundCounter = 11;
	
	for(new i = 1; i < 33; i++)
	{
		g_HasLuck[i] = false;
		g_HasVotedRR[i] = false;
		g_HasSpeed[i] = false;
		
		if(!is_user_connected(i) || is_user_bot(i)) continue;
		
		if(get_pdata_int(i, 114, 5) == 1 && g_Terrorist == -1)
		{
			g_Terrorist = i;
			set_task(1.0, "show_menu_freeround", i + 531);
		}
	}

	new playersnum = get_playersnum() - 1;
	switch(playersnum)
	{
		case 0 .. 2: g_VotesNeeded = playersnum;
		case 3 .. 5: g_VotesNeeded = playersnum - 1;
		case 6 .. 9: g_VotesNeeded = playersnum - 2;
		case 10 .. 13: g_VotesNeeded = 8;
		case 14 .. 32: g_VotesNeeded = playersnum - 6;
	}

	g_VotesForRR = 0;
}

public event_DeathMsg()
{
	new victim = read_data(2);
	new killer = read_data(1);

	if(victim != g_Terrorist && checkfreeround()) set_task(1.0, "PlayerRespawn", victim);
	
	if(!killer || !victim || killer == victim) return;
	
	g_Points[killer]++;
	print_color(killer, "^x03%s^x01 Recibes^x04 1^x01 punto por matar a^x04 %s", PREFIX, g_PlayerName[victim]);
}

public clcmd_SaySpeed(id)
{
	menu_deathrun(id, 0, 5);
	
	return PLUGIN_HANDLED;
}

public clcmd_SayCam(id)
{
	menu_deathrun(id, 0, 6);
	
	return PLUGIN_HANDLED;
}

public clcmd_JoinTeam(id)  return (CS_TEAM_T <= cs_get_user_team(id) <= CS_TEAM_CT) ? PLUGIN_HANDLED : PLUGIN_CONTINUE;

public clcmd_voterr(id)
{
	if(!g_HasVotedRR[id])
	{
		g_VotesForRR++;
		g_HasVotedRR[id] = true;
		CheckVotesForRR(id);
	}
	else print_color(id, "^x03%s^x01 Ya has votado para un restart.", PREFIX);
}

public concmd_DarPuntos(id)
{
	if(!(get_user_flags(id) & ADMIN_RCON)) return PLUGIN_CONTINUE;
	
	static target[33], puntosnum[10], player;
	read_argv(1, target, 32);
	read_argv(2, puntosnum, 9);
	
	if(equal(target, ""))
		client_print(id, print_console, "Uso: darpuntos <nombre|@> # - Dar puntos zombie al jugador.");
	else if(target[0] == '@')
	{
		for(new i=1; i < 33; i++)
		{
			g_Points[i] += str_to_num(puntosnum);
		}
		
		client_print(id, print_console, "Has dado %d puntos a todos.", str_to_num(puntosnum));
	}
	else
	{
		player = find_player("bl", target);
		
		if(!player) client_print(id, print_console, "No se encontro a ese jugador.");
		else if(player != find_player("blj",target)) 
			client_print(id, print_console, "Mas de un jugador coincide con el argumento.");
		else
		{
			g_Points[player] += str_to_num(puntosnum);
			client_print(id, print_console, "Has dado %d puntos a %s. Ahora tiene %d puntos.", str_to_num(puntosnum), g_PlayerName[player], g_Points[player]);
		}
	}
	
	return PLUGIN_HANDLED;
}

public PlayerRespawn(id) if(is_user_connected(id) && !is_user_alive(id)) ExecuteHamB(Ham_CS_RoundRespawn, id);

CheckVotesForRR(id)
{
	if(g_VotesForRR >= g_VotesNeeded)
	{
		set_cvar_float("sv_restartround", 2.0);
		print_color(0, "^x03%s^x01 Se alcanzaron los votos necesarios para reiniciar la ronda.^x04 Reiniciando en 2 segundos.", PREFIX);
		for(new i = 1; i < 33; i++)
		{
			g_HasVotedRR[i] = true;
		}
	}
	else
	{
		new short = g_VotesNeeded - g_VotesForRR;
		print_color(0, "^x03%s^x04 %s^x01 ha votado para reiniciar la ronda. Se requiere%s^x04 %d^x01 voto%s mas.", PREFIX, g_PlayerName[id], short == 1 ? "" : "n", short, short == 1 ? "" : "s");
	}
}

print_color(id, const input[], any:...)
{
	static szMsg[191], msgSayText;
	
	if (!msgSayText)
		msgSayText = get_user_msgid("SayText");
	
	vformat(szMsg, 190, input, 3);
	
	message_begin(id ? MSG_ONE_UNRELIABLE : MSG_BROADCAST, msgSayText, .player = id);
	write_byte(id ? id : 33);
	write_string(szMsg);
	message_end();
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang10250\\ f0\\ fs16 \n\\ par }
*/
