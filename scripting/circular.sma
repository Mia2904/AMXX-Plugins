/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <engine>
#include <xs>

#define PLUGIN "Name"
#define VERSION "0.1"
#define AUTHOR "Mia2904"

new const REGALO_MODEL[] = "models/zombie_plague/presents.mdl"

const Float:RADIUS = 100.0

public plugin_precache()
{
	precache_model(REGALO_MODEL)
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_clcmd("test", "test_it");
	
	register_think("giratorio", "giratorio_think");
}

public test_it(id)
{
	new Float:origin[3]
	entity_get_vector(id, EV_VEC_origin, origin);
	
	new ent = create_entity("info_target");
	
	origin[0] = origin[0] + RADIUS;
	
	entity_set_origin(ent, origin);
	entity_set_model(ent, /*algun model*/ "models/zombie_plague/presents.mdl");
	DispatchSpawn(ent);
	entity_set_int(ent, EV_INT_solid, SOLID_NOT);
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_FLY);
	entity_set_size(ent, Float:{-10.0,-10.0,0.0},Float:{10.0,10.0,25.0})
	
	entity_set_edict(ent, EV_ENT_owner, id);
	entity_set_string(ent, EV_SZ_classname, "giratorio");
	entity_set_float(ent, EV_FL_fuser1, RADIUS);
	entity_set_float(ent, EV_FL_fuser2, 0.0);
	entity_set_float(ent, EV_FL_nextthink, halflife_time() + 0.01);
	
	/*new Data[3]
	Data[0] = id;
	Data[1] = _:RADIUS;
	Data[2] = 0
	set_task(0.1, "animar", ent, Data, 3);*/
}

/*
public animar(Data[], ent)
{
	static Float:c_origin[3], Float:radius, id;
	id = Data[0];
	radius = Float:Data[1];
	
	entity_get_vector(id, EV_VEC_origin, c_origin);
	
	calcular_siguiente_posicion(c_origin, radius, Data[2]);
	
	entity_set_vector(ent, EV_VEC_origin, c_origin)
	
	if (++Data[2] >= 360)
		Data[2] = 0;
	
	set_task(0.1, "animar", ent, Data, 3);
}*/

public giratorio_think(ent)
{
	static Float:c_origin[3], Float:radius, Float:angulo, id;
	
	id = entity_get_edict(ent, EV_ENT_owner)
	entity_get_vector(id, EV_VEC_origin, c_origin);
	radius = entity_get_float(ent, EV_FL_fuser1);
	angulo = entity_get_float(ent, EV_FL_fuser2);
	
	calcular_siguiente_posicion(c_origin, radius, angulo);
	
	entity_set_vector(ent, EV_VEC_origin, c_origin)
	
	if (angulo >= 359.9)
		angulo = 0.0;
	else
		angulo = angulo + 0.2;
	
	entity_set_float(ent, EV_FL_fuser2, angulo);
	
	entity_set_float(ent, EV_FL_nextthink, halflife_time() + 0.001);
}

calcular_siguiente_posicion(Float:origin[3], const Float:radius, const Float:angulo)
{
	if (0 <= angulo <= 90)
	{
		origin[0] = origin[0] + (radius * floatcos(angulo, degrees));
		origin[1] = origin[1] + (radius * floatsin(angulo, degrees));
	}
	else if (90.0 <= angulo <= 179.99)
	{
		origin[0] = origin[0] - (radius * floatsin(angulo-90.0, degrees));
		origin[1] = origin[1] + (radius * floatcos(angulo-90.0, degrees));
	}
	else if (180.0 <= angulo <= 269.99)
	{
		origin[0] = origin[0] - (radius * floatcos(angulo-180.0, degrees));
		origin[1] = origin[1] - (radius * floatsin(angulo-180.0, degrees));
	}
	else if (270.0 <= angulo <= 359.99)
	{
		origin[0] = origin[0] + (radius * floatsin(angulo-270.0, degrees));
		origin[1] = origin[1] - (radius * floatcos(angulo-270.0, degrees));
	}
}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang10250\\ f0\\ fs16 \n\\ par }
*/
