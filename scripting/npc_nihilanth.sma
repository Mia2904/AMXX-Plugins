/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <engine>
#include <cs_snarks>
#include <fakemeta>
#include <fun>
#include <hamsandwich>
#include <xs>

#define PLUGIN "NPC Nihilanth"
#define VERSION "Beta 0.6"
#define AUTHOR "Mia2904"

enum (+= 111)
{
	TASK_DRUG = 5151,
	TASK_CONTROL,
	TASK_POISON,
	TASK_SOUNDS
}

enum _:Vector
{
	X = 0,
	R = 0,
	Y = 1,
	G = 1,
	Z = 2,
	B = 2
}

enum
{
	STATUS_NOTHINK = 0,
	STATUS_IDLE,
	STATUS_ATTACK,
	STATUS_RECHARGE,
	STATUS_ENDATTACK
}

enum
{
	SOUND_NONE = 0,
	SOUND_IDLE,
	SOUND_PAIN,
	SOUND_RECHARGE,
	SOUND_ATTACK,
	SOUND_CHARGE
}

enum SprIndex
{
	SPR_FLARE6 = 0,
	SPR_LIGHTNING,
	SPR_XBEAM5,
	SPR_BLOOD,
	SPR_BLOODSPRAY,
	SPR_SMOKE,
	SPR_EXPLODE
}

enum RgbColor
{
	COLOR_WHITE = 0,
	COLOR_RED,
	COLOR_GREEN,
	COLOR_BLUE,
	COLOR_YELLOW,
	COLOR_CYAN,
	COLOR_MAGENTA,
	COLOR_PURPLE,
	COLOR_ORANGE
}

new const RGB_COLORS[RgbColor][Vector] =
{
	{	150,	170,	200	},	// Blanco
	{	255,	0,	0	},	// Rojo
	{	0,	255,	0	},	// Verde
	{	0,	0,	255	},	// Azul
	{	255,	255,	0	},	// Amarillo
	{	0,	250,	250	},	// Celeste
	{	170,	50,	100	},	// Magenta
	{	100,	50,	200	},	// Morado
	{	255,	150,	100	}	// Naranja
}

const TIEMPO_CONTROL = 5

const TIEMPO_DROGA = 5

const BLOOD_COLOR_YELLOW = 195

const Float:VIDA_NIHILANTH = 1000000.0;
const Float:HEALTH_MULTIPLIER = 85000.0;

const Float:ATTACK_RADIUS = 3000.0

new const SONIDOS_DROGA[][] =
{
	"houndeye/he_pain1.wav",
	"houndeye/he_pain3.wav",
	"houndeye/he_pain4.wav",
	"houndeye/he_pain5.wav",
	"houndeye/he_alert3.wav",
	"bullchicken/bc_attackgrowl.wav"
}

new const NPC_CLASSNAME[] = "npc_nihilanth";

new const NPC_MODEL[] = "models/nihilanth.mdl"

//new const hp_spr[] = "sprites/zil_hp_bar.spr"

new const AttackSounds[][] = 
{
	"X/x_attack1.wav",
	"X/x_attack2.wav",
	"X/x_attack3.wav"
};

new const AppearSound[] = "nihilanth/nil_win.wav";

new const BallSound[] = "X/x_ballattack1.wav"

new const ShootSound[] = "X/x_shoot1.wav"

new const TeleportSound[] = "x/x_teleattack1.wav"

new const RechargeSounds[][] = 
{
	"X/x_recharge1.wav",
	"X/x_recharge2.wav",
	"X/x_recharge3.wav"
};

new const LaughSounds[][] = 
{
	"X/x_laugh1.wav",
	"X/x_laugh2.wav"
};

new const PainSounds[][] = 
{
	"X/x_pain1.wav",
	"X/x_pain2.wav"
}

new const DeathSound[] = "X/x_die1.wav"

new g_model, g_ent, g_sound, g_status, Float:g_fullhp;
//new y_hpbar;
new Float:g_origin[Vector], Float:g_angles[Vector], Float:g_v_angles[Vector];
new int_origin[3];
new g_sprindex[SprIndex]
new g_msgScreenFade, g_msgScreenShake;

//new g_testmenu

public plugin_precache()
{
	new mapname[14];
	get_mapname(mapname, 13);
	if (!equal(mapname, "zil_nihilanth"))
		return;
	
	g_model = engfunc(EngFunc_PrecacheModel, NPC_MODEL)
	
	g_sprindex[SPR_BLOOD] = precache_model("sprites/blood.spr")
	g_sprindex[SPR_BLOODSPRAY] = precache_model("sprites/bloodspray.spr")
	g_sprindex[SPR_FLARE6] = precache_model("sprites/Flare6.spr")
	g_sprindex[SPR_LIGHTNING] = precache_model("sprites/lgtning.spr")
	g_sprindex[SPR_XBEAM5] = precache_model("sprites/xbeam5.spr")
	g_sprindex[SPR_SMOKE] = precache_model("sprites/smoke.spr")
	g_sprindex[SPR_EXPLODE] = precache_model("sprites/fire_explode.spr");
	
	g_origin[X] = 420.0
	g_origin[Y] = 1330.0
	g_origin[Z] = 2100.0
	
	int_origin[0] = 420
	int_origin[1] = 1330
	int_origin[2] = 2100
	
	g_angles[X] = 0.25
	g_angles[Y] = 0.20
	
	g_v_angles[X] = -0.75
	g_v_angles[Y] = 0.20
	
	precache_sound(DeathSound);
	precache_sound(PainSounds[0]);
	precache_sound(PainSounds[1]);
	precache_sound(BallSound);
	precache_sound(LaughSounds[0]);
	precache_sound(LaughSounds[1]);
	precache_sound(RechargeSounds[0]);
	precache_sound(RechargeSounds[1]);
	precache_sound(RechargeSounds[2]);
	precache_sound(ShootSound);
	precache_sound(TeleportSound);
	precache_sound(AttackSounds[0]);
	precache_sound(AttackSounds[1]);
	precache_sound(AttackSounds[2]);
	precache_sound(AppearSound);
	
	precache_sound("nihilanth/nil_thieves.wav");
	
	//precache_model(hp_spr)
	
	for (new i = 0; i < sizeof(SONIDOS_DROGA); i++)
		precache_sound(SONIDOS_DROGA[i]);
	
	//create_npc();
}

public plugin_natives()
{
	register_native("npc_nihilanth_spawn", "native_spawn", 0);
	register_native("npc_nihilanth_getid", "native_getid", 0);
}

public native_spawn()
	return create_npc();

public native_getid()
	return g_ent;

public plugin_init()
{
	server_cmd("no_amxx_uncompress"); 
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	new mapname[14];
	get_mapname(mapname, 13);
	if (!equal(mapname, "zil_nihilanth"))
		return;
	
	register_think(NPC_CLASSNAME, "npc_think");
	register_touch(NPC_CLASSNAME, "player", "fw_NpcTouch");
	
	/*register_clcmd("nih", "clcmd_nih");
	
	register_clcmd("sou", "clcmd_sou");
	
	register_clcmd("inv", "clcmd_hh");*/
	
	register_clcmd("say /revivir", "player_respawn");
	
	set_task(3.0, "task_sounds", TASK_SOUNDS, .flags = "b");
	
	g_msgScreenFade = get_user_msgid("ScreenFade");
	g_msgScreenShake = get_user_msgid("ScreenShake");
	
	RegisterHam(Ham_Killed, "player", "fw_PlayerKilled_Post", 1);

	/*g_testmenu = menu_create("Animacion Nihilanth", "menu_nih")
	menu_additem(g_testmenu, "Anterior");
	menu_additem(g_testmenu, "Siguiente^n^n\yActual:\r 0^n");
	menu_additem(g_testmenu, "Ataque 1");
	menu_additem(g_testmenu, "Ataque 2");
	menu_additem(g_testmenu, "Ataque 3");
	menu_additem(g_testmenu, "Ataque 4^n");
	menu_additem(g_testmenu, "\yNPC Think: \rOFF");
	menu_additem(g_testmenu, "\yRayo laser color: \r0^n");
	menu_additem(g_testmenu, "\yColor sangre:\r 0^n");
	menu_additem(g_testmenu, "\ySalir");
	menu_setprop(g_testmenu, MPROP_PERPAGE, 0)*/
}

public task_sounds()
{
	if (!g_ent)
		return;
	
	switch (g_sound)
	{
		case SOUND_PAIN:
		{
			emit_sound(g_ent, CHAN_VOICE, PainSounds[random(sizeof(PainSounds))], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
			entity_set_int(g_ent, EV_INT_sequence, 21);
			g_sound = SOUND_IDLE;
		}
		case SOUND_IDLE: emit_sound(g_ent, CHAN_VOICE, LaughSounds[random(sizeof(LaughSounds))], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		case SOUND_ATTACK: emit_sound(g_ent, CHAN_VOICE, AttackSounds[random(sizeof(AttackSounds))], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		case SOUND_RECHARGE: emit_sound(g_ent, CHAN_VOICE, RechargeSounds[random(sizeof(RechargeSounds))], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
	}
	
	kill_in_sphere(300.0, Float:{ 420.0, 1330.0, 1500.0 });
}

create_npc()
{
	g_ent = create_entity("info_target");
	
	entity_set_origin(g_ent, g_origin)
	entity_set_vector(g_ent, EV_VEC_angles, g_angles)
	entity_set_vector(g_ent, EV_VEC_v_angle, g_v_angles)
	
	entity_set_float(g_ent, EV_FL_takedamage, 0.5)
	g_fullhp = floatmax(get_playersnum() * HEALTH_MULTIPLIER, VIDA_NIHILANTH);
	entity_set_float(g_ent, EV_FL_health, g_fullhp)
	
	entity_set_string(g_ent,EV_SZ_classname, NPC_CLASSNAME)
	
	entity_set_model(g_ent, NPC_MODEL)
	entity_set_int(g_ent, EV_INT_solid, SOLID_BBOX)
	entity_set_int(g_ent, EV_INT_movetype, MOVETYPE_NONE)
	
	new Float:mins[3] = { -300.0, -300.0, 0.0 }
	new Float:maxs[3] = { 300.0, 300.0, 512.0 }
	
	entity_set_size(g_ent, mins, maxs)
	entity_set_int(g_ent, EV_INT_modelindex, g_model)
	
	entity_set_float(g_ent, EV_FL_animtime, get_gametime())
	entity_set_float(g_ent, EV_FL_framerate, 1.0)
	
	g_status = STATUS_IDLE;
	entity_set_int(g_ent, EV_INT_sequence, 4)
	
	entity_set_float(g_ent, EV_FL_nextthink, halflife_time() + 0.01)
	
	RegisterHamFromEntity(Ham_TakeDamage, g_ent, "fw_TakeDamage", true)
	RegisterHamFromEntity(Ham_Killed, g_ent, "fw_Killed", true)
	
	/*y_hpbar = create_entity("env_sprite");
	entity_set_model(y_hpbar, hp_spr);
	g_origin[2] += 400.0	;
	entity_set_origin(y_hpbar, g_origin);
	g_origin[2] -= 400.0;
	entity_set_float(y_hpbar, EV_FL_frame, 14.0);*/
	
	drop_to_floor(g_ent);
	
	return g_ent;
}

public npc_think(entity)
{
	switch (g_status)
	{
		case STATUS_IDLE:
		{
			static const IDLE_ANIMS[] = { 1, 15, 16, 17 };
			
			entity_set_int(g_ent, EV_INT_sequence, IDLE_ANIMS[random(sizeof(IDLE_ANIMS))])
			g_sound = SOUND_IDLE;
			g_status = STATUS_RECHARGE;
			entity_set_float(g_ent, EV_FL_nextthink, halflife_time() + 2.0);
		}
		case STATUS_RECHARGE:
		{
			static const RECHARGE_ANIMS[] = { 3, 14, 18 };
			
			entity_set_int(g_ent, EV_INT_sequence, RECHARGE_ANIMS[random(sizeof(RECHARGE_ANIMS))])
			g_sound = SOUND_CHARGE;
			g_status = STATUS_ATTACK;
			entity_set_float(g_ent, EV_FL_nextthink, halflife_time() + 2.0);
		}
		case STATUS_ATTACK:
		{
			g_sound = SOUND_ATTACK;
			
			static const ATTACK_ANIMS[] = { 1, 2, 15, 16 };
			
			entity_set_int(g_ent, EV_INT_sequence, ATTACK_ANIMS[random(sizeof(ATTACK_ANIMS))])
			
			static attack;
			
			if (attack == (1<<1|1<<2|1<<3|1<<4|1<<5|1<<6))
				attack = 0;
			
			new i = 1;
			while (i)
			{
				i = random_num(1,6);
				
				if (attack & (1<<i))
					continue;
				
				attack |= (1<<i);
				break;
			}
			
			npc_do_attack(i);
			g_status = STATUS_ENDATTACK;
			entity_set_float(g_ent, EV_FL_nextthink, halflife_time() + 3.0);
		}
		case STATUS_ENDATTACK:
		{
			entity_set_int(g_ent, EV_INT_sequence, 21)
			g_status = STATUS_RECHARGE;
			g_sound = SOUND_IDLE;
			entity_set_float(g_ent, EV_FL_nextthink, halflife_time() + 5.0);
		}
		case STATUS_NOTHINK:
		{
			g_sound = SOUND_NONE;
			entity_set_int(g_ent, EV_INT_sequence, 21);
		}
	}
}

kill_in_sphere(Float:radius, Float:v_origin[Vector])
{
	static players[32], ent, num;
	
	num = find_sphere_class(-1, "player", radius, players, sizeof players, v_origin);
	
	if (!num)
		return;
	
	for (new i = 0; i < num; i++)
	{
		ent = players[i];
		
		if (!is_user_alive(ent))
			continue;
		
		user_kill(ent);
	}
}

public fw_NpcTouch(ent, id)
{
	if (is_user_alive(id))
		user_kill(id);
}

public fw_TakeDamage(victim, inflictor, attacker, Float:damage, damagebits)
{
	if (victim != g_ent || damage <= 0.0)
		return;
	
	//entity_set_float(y_hpbar, EV_FL_frame, 14.0 * entity_get_float(victim, EV_FL_health)/g_fullhp);
	
	if (g_sound == SOUND_IDLE)
	{
		g_sound = SOUND_PAIN;
		static const PAIN_ANIMS[] = { 9, 10, 11, 12 };
		entity_set_int(g_ent, EV_INT_sequence, PAIN_ANIMS[random(sizeof(PAIN_ANIMS))]);
	}
	
	static drop;
	drop++;
	
	if (drop == 500)
	{
		drop = 0;
		
		if (damage > 0.0)
			UTIL_BloodDrops(g_origin, BLOOD_COLOR_YELLOW, _:damage);
	}
}

public fw_Killed(victim, attacker)
{
	if (victim != g_ent)
		return;
	
	g_sound = SOUND_NONE;
	remove_task(TASK_SOUNDS);
	
	//remove_entity(y_hpbar);
	
	new ent = create_entity("info_target");
	
	entity_set_origin(ent, g_origin)
	entity_set_vector(ent, EV_VEC_angles, g_angles)
	entity_set_vector(ent, EV_VEC_v_angle, g_v_angles)
	
	entity_set_model(ent, NPC_MODEL)
	entity_set_int(ent, EV_INT_solid, SOLID_BBOX)
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE)
	
	new Float:mins[3] = { -300.0, -300.0, 0.0 }
	new Float:maxs[3] = { 300.0, 300.0, 512.0 }
	
	entity_set_size(ent, mins, maxs)
	entity_set_int(ent, EV_INT_modelindex, g_model)
	
	entity_set_float(ent, EV_FL_animtime, get_gametime())
	entity_set_float(ent, EV_FL_framerate, 1.0)
	
	entity_set_int(ent, EV_INT_sequence, 12)
	
	drop_to_floor(ent);
	
	npc_large_funnel();
	
	set_task(0.5, "npc_explotion", .flags = "a", .repeat = 5);
	
	// Hacer task para remover entidad
	// Y mostrar efectos de muerte
	// Mientras un task en el zombie para dar premio, pantalla oscura con hud y cambio de mapa
	set_task(2.5, "kill_npc", ent);
}

public kill_npc(ent)
{
	remove_entity(ent);
	
	#define FFADE_STAYOUT 0x0004
	
	message_begin(MSG_BROADCAST, g_msgScreenFade);
	write_short(5*4096);
	write_short(20*4096);
	write_short(FFADE_STAYOUT);
	write_byte(0);
	write_byte(0);
	write_byte(0);
	write_byte(255);
	message_end();
}

public fw_PlayerKilled_Post(victim)
{
	set_task(1.0, "player_respawn", victim);
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_KILLBEAM);
	write_short(victim);
	message_end();
}

public task_poison(id)
{
	id -= TASK_POISON;
	
	if (!is_user_connected(id) || !is_user_alive(id))
		return;
	
	ExecuteHamB(Ham_TakeDamage, id , g_ent, g_ent, 3000.0, DMG_ACID);
}

public player_respawn(id)
{
	static Float:v_origin[Vector];
	if (is_user_connected(id) && !is_user_alive(id) && (1 <= get_user_team(id) <= 2))
	{
		ExecuteHamB(Ham_CS_RoundRespawn, id);
		
		if (!g_ent)
			return;
		
		do
		{
			v_origin[X] = random_float(1200.0, 2000.0);
			v_origin[Y] = random_float(250.0, 2300.0);
			v_origin[Z] = random_num(0, 1) ? 1200.0 : 1700.0;
		}
		while (!is_hull_vacant(v_origin, HULL_HUMAN));
		
		entity_set_origin(id, v_origin);
	}
}

npc_do_attack(attack)
{
	static victim, players[32], num;
	static Float:v_origin[Vector], try;
	
	switch (attack)
	{
		case 1: // Droga
		{
			npc_beam_torus(.color = COLOR_GREEN);
			screen_shake(0);
			
			get_players(players, num, "ach");
			
			new i = 0;
			
			try = 0;
			
			while (i < num/2)
			{
				victim = players[random(num)];
				
				if (try & (1<<victim-1))
					continue;
				
				try |= (1<<victim-1);
				i++;
				
				drug_effect(victim+TASK_DRUG);
				remove_task(victim+TASK_DRUG);
				set_task(0.5, "drug_effect", victim+TASK_DRUG, .flags = "a", .repeat = TIEMPO_DROGA*2);
				ExecuteHamB(Ham_TakeDamage, victim , g_ent, g_ent, random_float(50.0, 150.0), DMG_ENERGYBEAM);
			}
		}
		case 2: // Daï¿½o bruto
		{
			npc_beam_disk();
			screen_shake(0);
			emit_sound(0, CHAN_VOICE, BallSound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
			
			get_players(players, num, "ach");
			
			new i = 0;
			
			try = 0;
			
			while (i < num/2)
			{
				victim = players[random(num)];
				
				if (try & (1<<victim-1))
					continue;
				
				try |= (1<<victim-1);
				i++;
				
				screen_fade(victim, COLOR_RED, 200, 3);
				ExecuteHamB(Ham_TakeDamage, victim , g_ent, g_ent, 10000.0, DMG_ENERGYBEAM);
			}
		}
		case 3: // Control mental
		{
			screen_shake(0);
			
			victim = -1;
			
			emit_sound(0, CHAN_VOICE, ShootSound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
			
			get_players(players, num, "ach");
			
			new i = 0;
			
			try = 0;
			
			while (i < num/4)
			{
				victim = players[random(num)];
				
				if (try & (1<<victim-1))
					continue;
				
				try |= (1<<victim-1);
				i++;
				
				npc_beam_ent(victim, SPR_XBEAM5, RgbColor:random(_:RgbColor), 255, 5);
				screen_shake(victim);
				mental_control_effect(victim+TASK_CONTROL);
				remove_task(victim+TASK_CONTROL)
				set_task(0.5, "mental_control_effect", victim+TASK_CONTROL, .flags = "a", .repeat = TIEMPO_CONTROL*2)
			}
		}
		case 4: // Teletransportacion
		{
			npc_beam_disk(.color = COLOR_YELLOW);
			
			get_players(players, num, "ach");
			
			new i = 0;
			
			try = 0;
			
			while (i < num/3)
			{
				victim = players[random(num)];
				
				if (try & (1<<victim-1))
					continue;
				
				try |= (1<<victim-1);
				i++;
				
				emit_sound(victim, CHAN_VOICE, TeleportSound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
				
				//entity_get_vector(victim, EV_VEC_origin, v_origin);
				//dynamic_light(v_origin);
				
				v_origin[Z] = 2350.0;
				
				do
				{
					v_origin[X] = random_float(2160.0, 2520.0);
					v_origin[Y] = random_float(180.0, 710.0);
				}
				while (!is_hull_vacant(v_origin, HULL_HUMAN))
				
				entity_set_vector(victim, EV_VEC_origin, v_origin);
				//beam_cylinder(v_origin, .color = COLOR_CYAN, .radius = 50.0);
			}
			
			// Snarks en el lugar
			/*num = 12, try = 1;
			v_origin[Z] = 2350.0;
			
			for (i = 0; i < num; i++)
			{
				v_origin[X] = 2500.0 + float((i % 5) * 32);
				v_origin[Y] = 1450.0 + float((i / 5) * 32);
				
				if (!is_hull_vacant(v_origin, HULL_HEAD))
				{
					if (++try > 5)
						break;
					
					num++;
					continue;
				}
				
				if (!cs_snark_create(g_ent, v_origin, g_angles, Float:{0.0,0.0,0.0}))
					break;
			}*/
		}
		case 5: // Terremoto y remover armas.
		{
			npc_beam_torus();
			
			screen_shake(0);
			screen_fade(0, .color = COLOR_RED);
			
			get_players(players, num, "ach");
			
			new i = 0;
			
			try = 0;
			
			while (i < num/2)
			{
				victim = players[random(num)];
				
				if (try & (1<<victim-1))
					continue;
				
				try |= (1<<victim-1);
				i++;
				
				strip_user_weapons(victim);
				give_item(victim, "weapon_knife");
				
				velocity_by_aim(victim, 500, v_origin);
				entity_set_vector(victim, EV_VEC_velocity, v_origin);
				
				screen_shake(victim);
				screen_fade(victim, .color = COLOR_RED);
			}
		}
		case 6: // Hacerse invisible y hacer explosiones en el mapa.
		{
			npc_make_invisible();
			screen_shake(0);
			set_task(2.1, "npc_do_explotions", 15);
		}
		/*case 7: // Snarks en las cabezas
		{
			npc_beam_disk(.color = COLOR_ORANGE);
			npc_make_invisible();
			set_task(2.1, "npc_do_snarks");
		}*/
	}
}

npc_make_invisible(fadeintime = 2, staytime = 7, fadeouttime = 2)
{
	new Data[2];
	Data[0] = fadeintime * 10;
	Data[1] = (25 / fadeintime);
	
	entity_set_int(g_ent, EV_INT_rendermode, kRenderTransAlpha);
	reduce_visibility(Data, 255);
	
	Data[0] = fadeouttime * 10;
	Data[1] = (25 / fadeintime);
	
	set_task(float(fadeintime+staytime), "increase_visibility", 0, Data, 2);
}

npc_beam_disk(SprIndex:sprite = SPR_LIGHTNING, RgbColor:color = COLOR_RED, speed = 0, Float:radius = 1000.0, brightness = 255, secs = 5)
{
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_BEAMDISK) // TE_BEAMDISK
	engfunc(EngFunc_WriteCoord, g_origin[X]); // Start X
	engfunc(EngFunc_WriteCoord, g_origin[Y]); // Start Y
	engfunc(EngFunc_WriteCoord, g_origin[Z]-200.0); // Start Z
	engfunc(EngFunc_WriteCoord, 0.0)		// coord coord coord (axis x, y, z)
	engfunc(EngFunc_WriteCoord, 0.0)
	engfunc(EngFunc_WriteCoord, radius)		
	/*engfunc(EngFunc_WriteCoord, g_origin[X]); // Start X
	engfunc(EngFunc_WriteCoord, g_origin[Y]); // Start Y
	engfunc(EngFunc_WriteCoord, g_origin[Z]); // Start Z
	engfunc(EngFunc_WriteCoord, g_origin[X]); // End X
	engfunc(EngFunc_WriteCoord, g_origin[Y]); // End Y
	engfunc(EngFunc_WriteCoord, g_origin[Z]+radius); // End Z*/
	write_short(g_sprindex[sprite])			// short (sprite index)
	write_byte(0)					// byte (starting frame)
	write_byte(0)					// byte (frame rate in 0.1's)
	write_byte(10*secs)				// byte (life in 0.1's)
	write_byte(0)					// byte (line width in 0.1's)
	write_byte(150)					// byte (noise amplitude in 0.01's)
	write_byte(RGB_COLORS[color][R])		// byte,byte,byte (color)
	write_byte(RGB_COLORS[color][G])
	write_byte(RGB_COLORS[color][B])
	write_byte(brightness)				// byte (brightness)
	write_byte(speed)				// byte (scroll speed in 0.1's)
	message_end()
}

npc_beam_torus(SprIndex:sprite = SPR_XBEAM5, RgbColor:color = COLOR_RED, speed = 0, Float:radius = 2500.0, brightness = 255, secs = 8)
{
	message_begin(MSG_PVS, SVC_TEMPENTITY, int_origin);
	write_byte(TE_BEAMTORUS);
	engfunc(EngFunc_WriteCoord, g_origin[X]); // Start X
	engfunc(EngFunc_WriteCoord, g_origin[Y]); // Start Y
	engfunc(EngFunc_WriteCoord, g_origin[Z]); // Start Z
	engfunc(EngFunc_WriteCoord, 0.0); // End X
	engfunc(EngFunc_WriteCoord, 0.0); // End Y
	engfunc(EngFunc_WriteCoord, radius); // End Z
	write_short(g_sprindex[sprite]); // sprite
	write_byte(0); // Starting frame
	write_byte(0); // framerate * 0.1
	write_byte(10*secs); // life * 0.1
	write_byte(500); // width
	write_byte(0); // noise
	write_byte(RGB_COLORS[color][R])		// byte,byte,byte (color)
	write_byte(RGB_COLORS[color][G])
	write_byte(RGB_COLORS[color][B])
	write_byte(brightness)				// byte (brightness)
	write_byte(speed)				// byte (scroll speed in 0.1's)
	message_end()
}

npc_beam_ent(id, SprIndex:sprite = SPR_XBEAM5, RgbColor:color = COLOR_WHITE, brightness = 255, secs = 5, noise = 20, speed = 50)
{
	message_begin(MSG_PVS, SVC_TEMPENTITY, int_origin)
	write_byte(TE_BEAMENTS)
	write_short(g_ent) 				// start entity
	write_short(id)					// end entity
	write_short(g_sprindex[sprite])			// sprite index
	write_byte(0)					// byte (starting frame)
	write_byte(0)					// byte (frame rate in 0.1's)
	write_byte(10*secs)				// byte (life in 0.1's)
	write_byte(50)					// byte (line width in 0.1's) 50
	write_byte(noise)				// byte (noise amplitude in 0.01's) 20
	write_byte(RGB_COLORS[color][R]) 		// Red
	write_byte(RGB_COLORS[color][G]) 		// Green
	write_byte(RGB_COLORS[color][B])	 	// Blue
	write_byte(brightness)				// brightness
	write_byte(speed) 				// (scroll speed in 0.1's)
	message_end()
}

npc_large_funnel(SprIndex:sprite = SPR_LIGHTNING, flag = 1)
{
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_LARGEFUNNEL)
	engfunc(EngFunc_WriteCoord, g_origin[X]); // Start X
	engfunc(EngFunc_WriteCoord, g_origin[Y]); // Start Y
	engfunc(EngFunc_WriteCoord, g_origin[Z]); // Start Z
	write_short(g_sprindex[sprite]) // sprite
	write_short(flag) // flag
	message_end()
}

public npc_explotion()
{
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_EXPLOSION)
	engfunc(EngFunc_WriteCoord, g_origin[0]+random_float(-150.0, 150.0))
	engfunc(EngFunc_WriteCoord, g_origin[1]+random_float(-150.0, 150.0))
	engfunc(EngFunc_WriteCoord, g_origin[2]+random_float(-150.0, 150.0))
	write_short(g_sprindex[SPR_EXPLODE])
	write_byte(30)
	write_byte(15)
	write_byte(0)
	message_end(); 
}

stock beam_cylinder(Float:origin[3], SprIndex:sprite = SPR_SMOKE, RgbColor:color = COLOR_GREEN, Float:radius = 2500.0, brightness = 255, secs  = 1)
{
	message_begin_f(MSG_PVS, SVC_TEMPENTITY, origin)
	write_byte(TE_BEAMCYLINDER)
	engfunc(EngFunc_WriteCoord, origin[X])
	engfunc(EngFunc_WriteCoord, origin[Y])
	engfunc(EngFunc_WriteCoord, origin[Z])
	engfunc(EngFunc_WriteCoord, 0.0)
	engfunc(EngFunc_WriteCoord, 0.0)
	engfunc(EngFunc_WriteCoord, radius)
	write_short(g_sprindex[sprite])
	write_byte(0)
	write_byte(0)
	write_byte(secs*10)
	write_byte(10)
	write_byte(0)
	write_byte(RGB_COLORS[color][R]) 		// Red
	write_byte(RGB_COLORS[color][G]) 		// Green
	write_byte(RGB_COLORS[color][B])	 	// Blue
	write_byte(brightness)
	write_byte(0)
	message_end()
}

screen_fade(id, RgbColor:color = COLOR_RED, alpha = 255, secs = 1)
{
	message_begin(id ? MSG_ONE_UNRELIABLE : MSG_BROADCAST, g_msgScreenFade, _, id)
	write_short(secs*4096) // duracion
	write_short(0) // tiempo de espera
	write_short(0x0000)
	write_byte(RGB_COLORS[color][R]) 		// Red
	write_byte(RGB_COLORS[color][G]) 		// Green
	write_byte(RGB_COLORS[color][B])	 	// Blue
	write_byte(alpha)
	message_end()
}

screen_shake(id, amplitude = 10)
{
	message_begin(id ? MSG_ONE_UNRELIABLE : MSG_BROADCAST, g_msgScreenShake, _,id)
	write_short(15*4096)
	write_short(4096*amplitude)
	write_short(200*256)
	message_end()
}

stock dynamic_light(Float:origin[3], radius = 50, RgbColor:color = COLOR_WHITE, secs = 10)
{
	message_begin_f(MSG_PVS, SVC_TEMPENTITY, origin);
	write_byte( TE_DLIGHT );
	engfunc(EngFunc_WriteCoord, origin[X])
	engfunc(EngFunc_WriteCoord, origin[Y])
	engfunc(EngFunc_WriteCoord, origin[Z])
	write_byte(radius)
	write_byte(RGB_COLORS[color][R]) 		// Red
	write_byte(RGB_COLORS[color][G]) 		// Green
	write_byte(RGB_COLORS[color][B])	 	// Blue
	write_byte(secs*10);	// life * 10
	write_byte(100)
	message_end();
}

public npc_do_explotions(tasknum)
{
	static const Float:explotion_origins[2][3] =
	{
		{ 423.0, 330.0, 1200.0 },
		{ 1849.0, 2303.0, 1710.0 }
	}
	
	static Float:exp_origin[Vector];
	exp_origin[X] = random_float(Float:explotion_origins[0][X], Float:explotion_origins[1][X]);
	exp_origin[Y] = random_float(Float:explotion_origins[0][Y], Float:explotion_origins[1][Y]);
	exp_origin[Z] = Float:explotion_origins[(tasknum%2) ? 1 : 0][Z];
	
	message_begin_f(MSG_PVS, SVC_TEMPENTITY, exp_origin);
	write_byte(TE_EXPLOSION)
	engfunc(EngFunc_WriteCoord, exp_origin[X])
	engfunc(EngFunc_WriteCoord, exp_origin[Y])
	engfunc(EngFunc_WriteCoord, exp_origin[Z])
	write_short(g_sprindex[SPR_EXPLODE])
	write_byte(30)
	write_byte(15)
	write_byte(0)
	message_end();
	
	new victim = -1;
	while ((victim = engfunc(EngFunc_FindEntityInSphere, victim, exp_origin, 800.0)) != 0)
	{
		if (!(1 <= victim <= 32) || !is_user_alive(victim))
			continue;
		
		ExecuteHamB(Ham_TakeDamage, victim , g_ent, g_ent, 1000.0, DMG_BLAST);
	}
	
	if (--tasknum)
		set_task(0.3, "npc_do_explotions", tasknum);
}

public npc_do_snarks()
{
	static players[32], num, victim, Float:v_origin[Vector];
	kill_in_sphere(500.0, Float:{ 420.0, 330.0, 1500.0 });
	kill_in_sphere(500.0, Float:{ 420.0, 1330.0, 1500.0 });
	kill_in_sphere(500.0, Float:{ 420.0, 2330.0, 1500.0 });
	
	get_players(players, num, "ach");
	
	new b = 0, i = 0, try = 0;

	while (i < num/4)
	{
		victim = players[random(num)];
		
		if (try & (1<<victim-1))
			continue;
		
		try |= (1<<victim-1);
		i++;
		
		entity_get_vector(victim, EV_VEC_origin, v_origin);
		
		for (b = 0; b < 4; b++)
		{
			v_origin[Z] = floatadd(Float:v_origin[Z], 32.0);
			
			if (is_hull_vacant(v_origin, HULL_HEAD))
			{
				if (cs_snark_create(g_ent, v_origin, g_angles, Float:{0.0,0.0,0.0}))
				{
					//npc_beam_ent(try, SPR_SMOKE, COLOR_PURPLE, 255, 1, 0, 0);
					if (i%2)
						beam_cylinder(v_origin, .radius = 50.0);
				}
				
				break;
			}
		}
	}
}

public drug_effect(id)
{
	id -= TASK_DRUG;
	
	if (!is_user_connected(id) || !is_user_alive(id))
	{
		remove_task(id+TASK_DRUG)
		return;
	}
	
	client_cmd(id, "stopsound");
	client_cmd(id, "spk ^"%s^"", SONIDOS_DROGA[random_num(0, charsmax(SONIDOS_DROGA))]);
	
	screen_fade(id, RgbColor:random(_:RgbColor), 255, 1);
	screen_shake(id, 1);
	
	// Seteamos el angulo en cualquier direccion
	static Float:fVec[3]
	fVec[0] = random_float(50.0, 150.0)
	fVec[1] = random_float(50.0, 150.0)
	fVec[2] = random_float(50.0, 150.0)
	entity_set_vector(id, EV_VEC_punchangle, fVec)
}

public mental_control_effect(id)
{
	id -= TASK_CONTROL;
	
	if (!is_user_alive(id) || !is_user_connected(id))
	{
		remove_task(id+TASK_CONTROL)
		return;
	}
	
	static Float:vret[3];
	vret[0] = random_float(50.0, 150.0)
	vret[1] = random_float(50.0, 150.0)
	vret[2] = random_float(50.0, 150.0)
	entity_set_vector(id, EV_VEC_punchangle, vret)
	
	entity_get_vector(id, EV_VEC_v_angle, vret);
	angle_vector(vret, ANGLEVECTOR_UP, vret);
	xs_vec_mul_scalar(vret, 500.0, vret);
	
	entity_set_vector(id, EV_VEC_velocity, vret);
	
	ExecuteHamB(Ham_TakeDamage, id, g_ent, g_ent, 50.0, DMG_ENERGYBEAM);
}

public reduce_visibility(Data[], lastval)
{
	lastval -= Data[1];
	entity_set_float(g_ent, EV_FL_renderamt, float(lastval));
	
	if (--Data[0])
		set_task(0.1, "reduce_visibility", lastval, Data, 2);
	else
	{
		if (lastval != 0)
			entity_set_float(g_ent, EV_FL_renderamt, 0.0);
		
		entity_set_float(g_ent, EV_FL_takedamage, 0.0);
	}
}

public increase_visibility(Data[], lastval)
{
	lastval += Data[1];
	entity_set_float(g_ent, EV_FL_renderamt, float(lastval));
	
	if (--Data[0])
		set_task(0.1, "increase_visibility", lastval, Data, 2);
	else
	{
		if (lastval != 255)
			entity_set_float(g_ent, EV_FL_renderamt, 255.0);
		
		entity_set_float(g_ent, EV_FL_takedamage, 0.5);
	}
}

UTIL_BloodDrops(Float:Origin[3], Color = 247, Amount = 16)
{
	message_begin_f(MSG_PVS, SVC_TEMPENTITY, Origin)
	write_byte(TE_BLOODSPRITE)
	engfunc(EngFunc_WriteCoord, Origin[X])
	engfunc(EngFunc_WriteCoord, Origin[Y])
	engfunc(EngFunc_WriteCoord, Origin[Z])
	write_short(g_sprindex[SPR_BLOOD])
	write_short(g_sprindex[SPR_BLOODSPRAY])
	write_byte(Color)
	write_byte(Amount)
	message_end()
}

bool:is_hull_vacant(Float:origin[3], hull)
{
	engfunc(EngFunc_TraceHull, origin, origin, 0, hull, 0, 0);
	
	if (!get_tr2(0, TR_StartSolid) && !get_tr2(0, TR_AllSolid) && get_tr2(0, TR_InOpen))
		return true;
	
	return false;
}

#if AMXX_VERSION_NUM < 183
stock message_begin_f(dest, msg_type, const Float:origin[3] = {0.0,0.0,0.0}, player = 0)
{
	engfunc(EngFunc_MessageBegin, dest,msg_type, origin, player);
}
#endif

/*public clcmd_nih(id)
{
	menu_display(id, g_testmenu)
}

public menu_nih(id, menu, item)
{
	static g_anim, RgbColor:num, blood;
	
	switch (item)
	{
		case 0: g_anim--;
		case 1: g_anim++;
		case 2: npc_do_attack(6)
		case 3: npc_do_attack(2)
		case 4: npc_do_attack(3)
		case 5: npc_do_attack(5)
		case 6:
		{
			if (g_status == STATUS_NOTHINK)
				g_status = STATUS_IDLE;
			else
				g_status = STATUS_NOTHINK;
			
			entity_set_float(g_ent, EV_FL_nextthink, halflife_time() + 0.01)
			
			menu_item_setname(menu, item, g_status == STATUS_NOTHINK ? "\yNPC Think: \dOFF" : "\yNPC Think: \rON")
		}
		case 7:
		{
			if (++num >= RgbColor)
				num = COLOR_WHITE;
			
			npc_beam_ent(id, .color = num, .secs = 2);
			
			new buffer[32]
			formatex(buffer, 31, "\yRayo laser color: \r%d^n", num);
			menu_item_setname(menu, item, buffer)
		}
		case 8:
		{
			if (++blood >= 255)
				blood = 0;
		3	static Float:origin[Vector];
			entity_get_vector(id, EV_VEC_origin, origin)
			origin[2] += 10.0
			UTIL_BloodDrops(origin, blood, 16)
			
			new buffer[32]
			formatex(buffer, 31, "\yColor sangre:\r %d", blood);
			menu_item_setname(menu, item, buffer);
		}
		case 9: return PLUGIN_HANDLED;
	}
	
	if (0 <= item <= 1)
	{
		if (g_anim < 1)
			g_anim = 21;
		else if (g_anim > 21)
			g_anim = 1;
		
		entity_set_int(g_ent, EV_INT_sequence, g_anim);
		new buffer[32]
		formatex(buffer, 31, "Siguiente^n^n\yActual:\r %d^n", g_anim)
		menu_item_setname(menu, 1, buffer)
	}
	
	menu_display(id, menu)
	return PLUGIN_HANDLED;
}

public clcmd_sou(id)
{
	entity_get_vector(id, EV_VEC_origin, g_origin)
	entity_get_vector(id, EV_VEC_angles, g_angles)
	entity_get_vector(id, EV_VEC_v_angle, g_v_angles)
	
	new File = fopen("zil_nihilanth.txt", "wt");
	
	fprintf(File, "Origin:^nX: %f Y: %f Z: %f^nAngles:^nX: %f Y: %f Z: %f^nV Angles:^nX: %f Y: %f Z: %f",
	g_origin[0], g_origin[1], g_origin[2], g_angles[0], g_angles[1], g_angles[2], g_v_angles[0], g_v_angles[1], g_v_angles[2]);
	
	fclose(File);
}

public clcmd_hh(id) entity_set_float(id, EV_FL_health, 100000.0);*/
